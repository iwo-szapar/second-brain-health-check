/**
 * Brain Manifest Generator
 *
 * Generates brain-manifest.yaml from health check results.
 * Three sections: Inventory (counts), Findings (lowest checks), Guide (tool list).
 *
 * Design rules:
 * - Only measured facts from check layers. No adjectives, no interpretations.
 * - No percentile claims (we have no aggregate data).
 * - Max 3 findings, sorted by point deficit (biggest gap first).
 * - Guide section says what tools DO, not what they'll achieve.
 * - The user (or Claude presenting results) draws conclusions, not us.
 */
import { writeFile } from 'node:fs/promises';
import { resolve } from 'node:path';
import { VERSION } from './version.js';

/**
 * Generate brain-manifest.yaml content from a health check report.
 * Returns a YAML string (hand-built â€” zero deps).
 */
export function generateManifestYaml(report) {
    const lines = [];
    const ts = report.timestamp || new Date().toISOString();
    const overallMax = report.setup.maxPoints + report.usage.maxPoints + report.fluency.maxPoints;
    const overallPts = report.setup.totalPoints + report.usage.totalPoints + report.fluency.totalPoints;
    const overallPct = overallMax > 0 ? Math.round((overallPts / overallMax) * 100) : 0;
    const grade = overallPct >= 80 ? 'A' : overallPct >= 65 ? 'B' : overallPct >= 50 ? 'C' : 'D';

    lines.push('# brain-manifest.yaml');
    lines.push(`# Generated by Second Brain Health Check v${VERSION}`);
    lines.push(`# ${ts}`);
    lines.push(`# Score: ${overallPct}/100 | Grade: ${grade}`);
    lines.push('');

    // === Section 1: Inventory ===
    // Pure counts from brainState + layer check messages.
    lines.push('# === INVENTORY ===');
    lines.push('inventory:');

    const has = report.brainState?.has || {};

    if (has.claudeMd) {
        const lineCount = extractNumber(report, 'CLAUDE.md Quality', /(\d+)\s*lines?/i);
        const sectionCount = extractNumber(report, 'CLAUDE.md Quality', /(\d+)\s*section/i);
        let val = '{ lines: ' + (lineCount || '?');
        if (sectionCount) val += ', sections: ' + sectionCount;
        val += ' }';
        lines.push('  claude_md: ' + val);
    }

    const skillCount = extractNumber(report, 'Skills', /(\d+)/) || 0;
    if (skillCount > 0 || has.skills) lines.push('  skills: ' + (skillCount || '?'));

    const memCount = extractNumber(report, 'Memory Architecture', /(\d+)/) || 0;
    if (memCount > 0 || has.memory) lines.push('  memory_files: ' + (memCount || '?'));

    const kbCount = extractNumber(report, 'Knowledge Base Architecture', /(\d+)/) || 0;
    if (kbCount > 0 || has.knowledge) lines.push('  knowledge_files: ' + (kbCount || '?'));

    const mcpCount = extractNumber(report, 'MCP Server Health', /(\d+)/) || 0;
    if (mcpCount > 0) lines.push('  mcp_servers: ' + mcpCount);

    const hookCount = extractNumber(report, 'Hooks', /(\d+)\s*hook/i) || 0;
    lines.push('  hooks: ' + hookCount);

    const agentCount = extractNumber(report, 'Agent Quality', /(\d+)/) || 0;
    if (agentCount > 0 || has.agents) lines.push('  agents: ' + (agentCount || '?'));

    // === Section 2: Lowest-scoring checks ===
    // Sorted by (maxPoints - points) desc. Top 3. Raw findings only.
    lines.push('');
    lines.push('# === LOWEST-SCORING CHECKS ===');

    const allLayers = [
        ...(report.setup?.layers || []),
        ...(report.usage?.layers || []),
        ...(report.fluency?.layers || []),
    ];

    const deficits = allLayers
        .filter(l => l.maxPoints > 0 && l.points < l.maxPoints)
        .map(l => ({
            name: l.name,
            points: l.points,
            maxPoints: l.maxPoints,
            deficit: l.maxPoints - l.points,
            finding: getBestCheckMessage(l),
        }))
        .sort((a, b) => b.deficit - a.deficit)
        .slice(0, 3);

    if (deficits.length === 0) {
        lines.push('findings: []  # All checks at max score');
    } else {
        lines.push('findings:');
        for (const d of deficits) {
            lines.push('  - check: ' + slugify(d.name));
            lines.push('    score: ' + d.points + '/' + d.maxPoints);
            lines.push('    finding: "' + d.finding + '"');
        }
    }

    // === Section 3: Guide tools ===
    // What they DO. No promises about outcomes.
    lines.push('');
    lines.push('# === GUIDE TOOLS (requires token) ===');
    lines.push('guide:');
    lines.push('  weekly_pulse: "Compares scores across runs"');
    lines.push('  context_pressure: "Breaks down token budget by source"');
    lines.push('  audit_config: "Checks for dead refs, overlaps, security"');
    lines.push('  optimize_brain: "Suggests specific config changes"');
    lines.push('  url: iwoszapar.com/context-engineering');

    return lines.join('\n') + '\n';
}

/**
 * Save manifest YAML to disk. Returns the output path.
 */
export async function saveManifest(report, outputPath) {
    const yaml = generateManifestYaml(report);
    const filePath = outputPath || resolve(report.path || process.cwd(), 'brain-manifest.yaml');
    await writeFile(filePath, yaml, 'utf-8');
    return filePath;
}

// --- Helpers ---

/**
 * Extract first number matching a pattern from a named layer's check messages.
 */
function extractNumber(report, layerName, pattern) {
    const allLayers = [
        ...(report.setup?.layers || []),
        ...(report.usage?.layers || []),
        ...(report.fluency?.layers || []),
    ];
    const layer = allLayers.find(l => l.name === layerName);
    if (!layer?.checks) return null;
    for (const check of layer.checks) {
        if (check.message) {
            const m = check.message.match(pattern);
            if (m) return parseInt(m[1], 10);
        }
    }
    return null;
}

/**
 * Get the most informative failing check message from a layer.
 * Prefers fail > warn, then highest deficit.
 */
function getBestCheckMessage(layer) {
    if (!layer?.checks?.length) return 'Score: ' + layer.points + '/' + layer.maxPoints;

    const failing = layer.checks
        .filter(c => c.status !== 'pass' && c.message)
        .sort((a, b) => {
            if (a.status === 'fail' && b.status !== 'fail') return -1;
            if (b.status === 'fail' && a.status !== 'fail') return 1;
            return (b.maxPoints - b.points) - (a.maxPoints - a.points);
        });

    if (failing.length > 0) return sanitize(failing[0].message);
    const first = layer.checks.find(c => c.message);
    return first ? sanitize(first.message) : 'Score: ' + layer.points + '/' + layer.maxPoints;
}

function slugify(name) {
    return name.toLowerCase().replace(/[^a-z0-9]+/g, '-').replace(/(^-|-$)/g, '');
}

function sanitize(str) {
    return str.replace(/"/g, '\\"').replace(/\n/g, ' ').slice(0, 200);
}
